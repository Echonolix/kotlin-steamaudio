// this file is auto generated by endoqa kotlin ffi, modify it with caution
package phonon

import java.lang.foreign.*
import java.lang.invoke.MethodHandle
import java.lang.invoke.VarHandle

@JvmInline
public value class IPLSimulationInputs(
    public val `$mem`: MemorySegment,
) {
    public var flags: IPLSimulationFlags
        get() = IPLSimulationFlags.fromInt(IPLSimulationInputs.flagsHandle.get(this.`$mem`, 0L) as Int)
        set(`value`) {
            IPLSimulationInputs.flagsHandle.set(this.`$mem`, 0L, value.value)
        }

    public var directFlags: IPLDirectSimulationFlags
        get() = IPLDirectSimulationFlags.fromInt(
            IPLSimulationInputs.directFlagsHandle.get(
                this.`$mem`,
                0L
            ) as Int
        )
        set(`value`) {
            IPLSimulationInputs.directFlagsHandle.set(this.`$mem`, 0L, value.value)
        }

    public var source: IPLCoordinateSpace3
        get() = IPLCoordinateSpace3(
            IPLSimulationInputs.sourceHandle.invokeExact(this.`$mem`, 0L) as
                    MemorySegment
        )
        set(`value`) {
            MemorySegment.copy(
                value.`$mem`, 0L, this.source.`$mem`, 0L,
                IPLCoordinateSpace3.layout.byteSize()
            )
        }

    public var distanceAttenuationModel: IPLDistanceAttenuationModel
        get() =
            IPLDistanceAttenuationModel(
                IPLSimulationInputs.distanceAttenuationModelHandle.invokeExact(
                    this.`$mem`,
                    0L
                ) as MemorySegment
            )
        set(`value`) {
            MemorySegment.copy(
                value.`$mem`, 0L, this.distanceAttenuationModel.`$mem`, 0L,
                IPLDistanceAttenuationModel.layout.byteSize()
            )
        }

    public var airAbsorptionModel: IPLAirAbsorptionModel
        get() =
            IPLAirAbsorptionModel(
                IPLSimulationInputs.airAbsorptionModelHandle.invokeExact(
                    this.`$mem`,
                    0L
                ) as MemorySegment
            )
        set(`value`) {
            MemorySegment.copy(
                value.`$mem`, 0L, this.airAbsorptionModel.`$mem`, 0L,
                IPLAirAbsorptionModel.layout.byteSize()
            )
        }

    public var directivity: IPLDirectivity
        get() = IPLDirectivity(
            IPLSimulationInputs.directivityHandle.invokeExact(this.`$mem`, 0L) as
                    MemorySegment
        )
        set(`value`) {
            MemorySegment.copy(
                value.`$mem`, 0L, this.directivity.`$mem`, 0L,
                IPLDirectivity.layout.byteSize()
            )
        }

    public var occlusionType: IPLOcclusionType
        get() = IPLOcclusionType.fromInt(
            IPLSimulationInputs.occlusionTypeHandle.get(this.`$mem`, 0L) as
                    Int
        )
        set(`value`) {
            IPLSimulationInputs.occlusionTypeHandle.set(this.`$mem`, 0L, value.value)
        }

    public var occlusionRadius: IPLfloat32
        get() = IPLSimulationInputs.occlusionRadiusHandle.get(this.`$mem`, 0L) as Float
        set(`value`) {
            IPLSimulationInputs.occlusionRadiusHandle.set(this.`$mem`, 0L, value)
        }

    public var numOcclusionSamples: IPLint32
        get() = IPLSimulationInputs.numOcclusionSamplesHandle.get(this.`$mem`, 0L) as Int
        set(`value`) {
            IPLSimulationInputs.numOcclusionSamplesHandle.set(this.`$mem`, 0L, value)
        }

    public val reverbScale: NativeArray<IPLfloat32>
        get() = IPLSimulationInputs.reverbScaleHandle.invokeExact(this.`$mem`, 0L) as MemorySegment

    public var hybridReverbTransitionTime: IPLfloat32
        get() = IPLSimulationInputs.hybridReverbTransitionTimeHandle.get(this.`$mem`, 0L) as Float
        set(`value`) {
            IPLSimulationInputs.hybridReverbTransitionTimeHandle.set(this.`$mem`, 0L, value)
        }

    public var hybridReverbOverlapPercent: IPLfloat32
        get() = IPLSimulationInputs.hybridReverbOverlapPercentHandle.get(this.`$mem`, 0L) as Float
        set(`value`) {
            IPLSimulationInputs.hybridReverbOverlapPercentHandle.set(this.`$mem`, 0L, value)
        }

    public var baked: IPLbool
        get() = IPLbool.fromInt(IPLSimulationInputs.bakedHandle.get(this.`$mem`, 0L) as Int)
        set(`value`) {
            IPLSimulationInputs.bakedHandle.set(this.`$mem`, 0L, value.value)
        }

    public var bakedDataIdentifier: IPLBakedDataIdentifier
        get() =
            IPLBakedDataIdentifier(
                IPLSimulationInputs.bakedDataIdentifierHandle.invokeExact(
                    this.`$mem`,
                    0L
                ) as MemorySegment
            )
        set(`value`) {
            MemorySegment.copy(
                value.`$mem`, 0L, this.bakedDataIdentifier.`$mem`, 0L,
                IPLBakedDataIdentifier.layout.byteSize()
            )
        }

    public var pathingProbes: IPLProbeBatch
        get() = IPLSimulationInputs.pathingProbesHandle.get(this.`$mem`, 0L) as MemorySegment
        set(`value`) {
            IPLSimulationInputs.pathingProbesHandle.set(this.`$mem`, 0L, value)
        }

    public var visRadius: IPLfloat32
        get() = IPLSimulationInputs.visRadiusHandle.get(this.`$mem`, 0L) as Float
        set(`value`) {
            IPLSimulationInputs.visRadiusHandle.set(this.`$mem`, 0L, value)
        }

    public var visThreshold: IPLfloat32
        get() = IPLSimulationInputs.visThresholdHandle.get(this.`$mem`, 0L) as Float
        set(`value`) {
            IPLSimulationInputs.visThresholdHandle.set(this.`$mem`, 0L, value)
        }

    public var visRange: IPLfloat32
        get() = IPLSimulationInputs.visRangeHandle.get(this.`$mem`, 0L) as Float
        set(`value`) {
            IPLSimulationInputs.visRangeHandle.set(this.`$mem`, 0L, value)
        }

    public var pathingOrder: IPLint32
        get() = IPLSimulationInputs.pathingOrderHandle.get(this.`$mem`, 0L) as Int
        set(`value`) {
            IPLSimulationInputs.pathingOrderHandle.set(this.`$mem`, 0L, value)
        }

    public var enableValidation: IPLbool
        get() = IPLbool.fromInt(IPLSimulationInputs.enableValidationHandle.get(this.`$mem`, 0L) as Int)
        set(`value`) {
            IPLSimulationInputs.enableValidationHandle.set(this.`$mem`, 0L, value.value)
        }

    public var findAlternatePaths: IPLbool
        get() = IPLbool.fromInt(
            IPLSimulationInputs.findAlternatePathsHandle.get(this.`$mem`, 0L) as
                    Int
        )
        set(`value`) {
            IPLSimulationInputs.findAlternatePathsHandle.set(this.`$mem`, 0L, value.value)
        }

    public var numTransmissionRays: IPLint32
        get() = IPLSimulationInputs.numTransmissionRaysHandle.get(this.`$mem`, 0L) as Int
        set(`value`) {
            IPLSimulationInputs.numTransmissionRaysHandle.set(this.`$mem`, 0L, value)
        }

    public constructor(gc: Boolean) : this(kotlin.run {
        require(gc) { "Do not call this if gc is not want" }
        Arena.ofAuto().allocate(IPLSimulationInputs.layout)
    })

    public companion object {
        public val layout: StructLayout = MemoryLayout.structLayout(
            ValueLayout.JAVA_INT.withName("flags"),
            ValueLayout.JAVA_INT.withName("directFlags"),
            IPLCoordinateSpace3.layout.withName("source"),
            IPLDistanceAttenuationModel.layout.withName("distanceAttenuationModel"),
            IPLAirAbsorptionModel.layout.withName("airAbsorptionModel"),
            IPLDirectivity.layout.withName("directivity"),
            ValueLayout.JAVA_INT.withName("occlusionType"),
            ValueLayout.JAVA_FLOAT.withName("occlusionRadius"),
            ValueLayout.JAVA_INT.withName("numOcclusionSamples"),
            MemoryLayout.sequenceLayout(3L, ValueLayout.JAVA_FLOAT).withName("reverbScale"),
            ValueLayout.JAVA_FLOAT.withName("hybridReverbTransitionTime"),
            ValueLayout.JAVA_FLOAT.withName("hybridReverbOverlapPercent"),
            ValueLayout.JAVA_INT.withName("baked"),
            IPLBakedDataIdentifier.layout.withName("bakedDataIdentifier"),
            java.lang.foreign.MemoryLayout.paddingLayout(4),
            `$RuntimeHelper`.POINTER.withName("pathingProbes"),
            ValueLayout.JAVA_FLOAT.withName("visRadius"),
            ValueLayout.JAVA_FLOAT.withName("visThreshold"),
            ValueLayout.JAVA_FLOAT.withName("visRange"),
            ValueLayout.JAVA_INT.withName("pathingOrder"),
            ValueLayout.JAVA_INT.withName("enableValidation"),
            ValueLayout.JAVA_INT.withName("findAlternatePaths"),
            ValueLayout.JAVA_INT.withName("numTransmissionRays"),
            java.lang.foreign.MemoryLayout.paddingLayout(4),
        ).withName("IPLSimulationInputs")

        @JvmField
        public val flagsHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("flags"))

        @JvmField
        public val directFlagsHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("directFlags"))

        @JvmField
        public val sourceHandle: MethodHandle =
            layout.sliceHandle(MemoryLayout.PathElement.groupElement("source"))

        @JvmField
        public val distanceAttenuationModelHandle: MethodHandle =
            layout.sliceHandle(MemoryLayout.PathElement.groupElement("distanceAttenuationModel"))

        @JvmField
        public val airAbsorptionModelHandle: MethodHandle =
            layout.sliceHandle(MemoryLayout.PathElement.groupElement("airAbsorptionModel"))

        @JvmField
        public val directivityHandle: MethodHandle =
            layout.sliceHandle(MemoryLayout.PathElement.groupElement("directivity"))

        @JvmField
        public val occlusionTypeHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("occlusionType"))

        @JvmField
        public val occlusionRadiusHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("occlusionRadius"))

        @JvmField
        public val numOcclusionSamplesHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("numOcclusionSamples"))

        @JvmField
        public val reverbScaleHandle: MethodHandle =
            layout.sliceHandle(MemoryLayout.PathElement.groupElement("reverbScale"))

        @JvmField
        public val hybridReverbTransitionTimeHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("hybridReverbTransitionTime"))

        @JvmField
        public val hybridReverbOverlapPercentHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("hybridReverbOverlapPercent"))

        @JvmField
        public val bakedHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("baked"))

        @JvmField
        public val bakedDataIdentifierHandle: MethodHandle =
            layout.sliceHandle(MemoryLayout.PathElement.groupElement("bakedDataIdentifier"))

        @JvmField
        public val pathingProbesHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("pathingProbes"))

        @JvmField
        public val visRadiusHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("visRadius"))

        @JvmField
        public val visThresholdHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("visThreshold"))

        @JvmField
        public val visRangeHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("visRange"))

        @JvmField
        public val pathingOrderHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("pathingOrder"))

        @JvmField
        public val enableValidationHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("enableValidation"))

        @JvmField
        public val findAlternatePathsHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("findAlternatePaths"))

        @JvmField
        public val numTransmissionRaysHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("numTransmissionRays"))

        @JvmStatic
        public fun allocate(alloc: SegmentAllocator): IPLSimulationInputs =
            IPLSimulationInputs(alloc.allocate(IPLSimulationInputs.layout))
    }
}
