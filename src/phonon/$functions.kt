// this file is auto generated by endoqa kotlin ffi, modify it with caution
package phonon

import java.lang.foreign.MemorySegment
import java.lang.foreign.SegmentAllocator

public fun iplContextCreate(settings: Pointer<IPLContextSettings>, context: Pointer<IPLContext>):
        IPLerror = IPLerror.fromInt(`iplContextCreate$mh`.invokeExact(settings, context) as Int)

public fun iplContextRetain(context: IPLContext): IPLContext =
    `iplContextRetain$mh`.invokeExact(context) as MemorySegment

public fun iplContextRelease(context: Pointer<IPLContext>): Unit =
    `iplContextRelease$mh`.invokeExact(context) as Unit

context(SegmentAllocator)
public fun iplCalculateRelativeDirection(
    context: IPLContext,
    sourcePosition: IPLVector3,
    listenerPosition: IPLVector3,
    listenerAhead: IPLVector3,
    listenerUp: IPLVector3,
): IPLVector3 =
    IPLVector3(
        `iplCalculateRelativeDirection$mh`.invokeExact(
            this@SegmentAllocator,
            context,
            sourcePosition.`$mem`,
            listenerPosition.`$mem`,
            listenerAhead.`$mem`,
            listenerUp.`$mem`,
        )
                as MemorySegment
    )

public fun iplSerializedObjectCreate(
    context: IPLContext,
    settings: Pointer<IPLSerializedObjectSettings>,
    serializedObject: Pointer<IPLSerializedObject>,
): IPLerror =
    IPLerror.fromInt(
        `iplSerializedObjectCreate$mh`.invokeExact(context, settings, serializedObject)
                as Int
    )

public fun iplSerializedObjectRetain(serializedObject: IPLSerializedObject): IPLSerializedObject =
    `iplSerializedObjectRetain$mh`.invokeExact(serializedObject) as MemorySegment

public fun iplSerializedObjectRelease(serializedObject: Pointer<IPLSerializedObject>): Unit =
    `iplSerializedObjectRelease$mh`.invokeExact(serializedObject) as Unit

public fun iplSerializedObjectGetSize(serializedObject: IPLSerializedObject): IPLsize =
    (`iplSerializedObjectGetSize$mh`.invokeExact(serializedObject) as Long).toULong()

public fun iplSerializedObjectGetData(serializedObject: IPLSerializedObject): Pointer<IPLbyte> =
    `iplSerializedObjectGetData$mh`.invokeExact(serializedObject) as MemorySegment

public fun iplEmbreeDeviceCreate(
    context: IPLContext,
    settings: Pointer<IPLEmbreeDeviceSettings>,
    device: Pointer<IPLEmbreeDevice>,
): IPLerror = IPLerror.fromInt(
    `iplEmbreeDeviceCreate$mh`.invokeExact(context, settings, device) as
            Int
)

public fun iplEmbreeDeviceRetain(device: IPLEmbreeDevice): IPLEmbreeDevice =
    `iplEmbreeDeviceRetain$mh`.invokeExact(device) as MemorySegment

public fun iplEmbreeDeviceRelease(device: Pointer<IPLEmbreeDevice>): Unit =
    `iplEmbreeDeviceRelease$mh`.invokeExact(device) as Unit

public fun iplOpenCLDeviceListCreate(
    context: IPLContext,
    settings: Pointer<IPLOpenCLDeviceSettings>,
    deviceList: Pointer<IPLOpenCLDeviceList>,
): IPLerror =
    IPLerror.fromInt(
        `iplOpenCLDeviceListCreate$mh`.invokeExact(context, settings, deviceList) as
                Int
    )

public fun iplOpenCLDeviceListRetain(deviceList: IPLOpenCLDeviceList): IPLOpenCLDeviceList =
    `iplOpenCLDeviceListRetain$mh`.invokeExact(deviceList) as MemorySegment

public fun iplOpenCLDeviceListRelease(deviceList: Pointer<IPLOpenCLDeviceList>): Unit =
    `iplOpenCLDeviceListRelease$mh`.invokeExact(deviceList) as Unit

public fun iplOpenCLDeviceListGetNumDevices(deviceList: IPLOpenCLDeviceList): IPLint32 =
    `iplOpenCLDeviceListGetNumDevices$mh`.invokeExact(deviceList) as Int

public fun iplOpenCLDeviceListGetDeviceDesc(
    deviceList: IPLOpenCLDeviceList,
    index: IPLint32,
    deviceDesc: Pointer<IPLOpenCLDeviceDesc>,
): Unit = `iplOpenCLDeviceListGetDeviceDesc$mh`.invokeExact(deviceList, index, deviceDesc) as Unit

public fun iplOpenCLDeviceCreate(
    context: IPLContext,
    deviceList: IPLOpenCLDeviceList,
    index: IPLint32,
    device: Pointer<IPLOpenCLDevice>,
): IPLerror =
    IPLerror.fromInt(
        `iplOpenCLDeviceCreate$mh`.invokeExact(context, deviceList, index, device) as
                Int
    )

public fun iplOpenCLDeviceCreateFromExisting(
    context: IPLContext,
    convolutionQueue: Pointer<Unit>,
    irUpdateQueue: Pointer<Unit>,
    device: Pointer<IPLOpenCLDevice>,
): IPLerror =
    IPLerror.fromInt(
        `iplOpenCLDeviceCreateFromExisting$mh`.invokeExact(context, convolutionQueue, irUpdateQueue, device)
                as Int
    )

public fun iplOpenCLDeviceRetain(device: IPLOpenCLDevice): IPLOpenCLDevice =
    `iplOpenCLDeviceRetain$mh`.invokeExact(device) as MemorySegment

public fun iplOpenCLDeviceRelease(device: Pointer<IPLOpenCLDevice>): Unit =
    `iplOpenCLDeviceRelease$mh`.invokeExact(device) as Unit

public fun iplRadeonRaysDeviceCreate(
    openCLDevice: IPLOpenCLDevice,
    settings: Pointer<IPLRadeonRaysDeviceSettings>,
    rrDevice: Pointer<IPLRadeonRaysDevice>,
): IPLerror =
    IPLerror.fromInt(
        `iplRadeonRaysDeviceCreate$mh`.invokeExact(openCLDevice, settings, rrDevice) as
                Int
    )

public fun iplRadeonRaysDeviceRetain(device: IPLRadeonRaysDevice): IPLRadeonRaysDevice =
    `iplRadeonRaysDeviceRetain$mh`.invokeExact(device) as MemorySegment

public fun iplRadeonRaysDeviceRelease(device: Pointer<IPLRadeonRaysDevice>): Unit =
    `iplRadeonRaysDeviceRelease$mh`.invokeExact(device) as Unit

public fun iplTrueAudioNextDeviceCreate(
    openCLDevice: IPLOpenCLDevice,
    settings: Pointer<IPLTrueAudioNextDeviceSettings>,
    tanDevice: Pointer<IPLTrueAudioNextDevice>,
): IPLerror =
    IPLerror.fromInt(
        `iplTrueAudioNextDeviceCreate$mh`.invokeExact(openCLDevice, settings, tanDevice)
                as Int
    )

public fun iplTrueAudioNextDeviceRetain(device: IPLTrueAudioNextDevice): IPLTrueAudioNextDevice =
    `iplTrueAudioNextDeviceRetain$mh`.invokeExact(device) as MemorySegment

public fun iplTrueAudioNextDeviceRelease(device: Pointer<IPLTrueAudioNextDevice>): Unit =
    `iplTrueAudioNextDeviceRelease$mh`.invokeExact(device) as Unit

public fun iplSceneCreate(
    context: IPLContext,
    settings: Pointer<IPLSceneSettings>,
    scene: Pointer<IPLScene>,
): IPLerror = IPLerror.fromInt(`iplSceneCreate$mh`.invokeExact(context, settings, scene) as Int)

public fun iplSceneRetain(scene: IPLScene): IPLScene = `iplSceneRetain$mh`.invokeExact(scene) as
        MemorySegment

public fun iplSceneRelease(scene: Pointer<IPLScene>): Unit =
    `iplSceneRelease$mh`.invokeExact(scene) as Unit

public fun iplSceneLoad(
    context: IPLContext,
    settings: Pointer<IPLSceneSettings>,
    serializedObject: IPLSerializedObject,
    progressCallback: IPLProgressCallback,
    progressCallbackUserData: Pointer<Unit>,
    scene: Pointer<IPLScene>,
): IPLerror =
    IPLerror.fromInt(
        `iplSceneLoad$mh`.invokeExact(
            context,
            settings,
            serializedObject,
            progressCallback,
            progressCallbackUserData,
            scene,
        )
                as Int
    )

public fun iplSceneSave(scene: IPLScene, serializedObject: IPLSerializedObject): Unit =
    `iplSceneSave$mh`.invokeExact(scene, serializedObject) as Unit

public fun iplSceneSaveOBJ(scene: IPLScene, fileBaseName: IPLstring): Unit =
    `iplSceneSaveOBJ$mh`.invokeExact(scene, fileBaseName) as Unit

public fun iplSceneCommit(scene: IPLScene): Unit = `iplSceneCommit$mh`.invokeExact(scene) as Unit

public fun iplStaticMeshCreate(
    scene: IPLScene,
    settings: Pointer<IPLStaticMeshSettings>,
    staticMesh: Pointer<IPLStaticMesh>,
): IPLerror = IPLerror.fromInt(
    `iplStaticMeshCreate$mh`.invokeExact(scene, settings, staticMesh) as
            Int
)

public fun iplStaticMeshRetain(staticMesh: IPLStaticMesh): IPLStaticMesh =
    `iplStaticMeshRetain$mh`.invokeExact(staticMesh) as MemorySegment

public fun iplStaticMeshRelease(staticMesh: Pointer<IPLStaticMesh>): Unit =
    `iplStaticMeshRelease$mh`.invokeExact(staticMesh) as Unit

public fun iplStaticMeshLoad(
    scene: IPLScene,
    serializedObject: IPLSerializedObject,
    progressCallback: IPLProgressCallback,
    progressCallbackUserData: Pointer<Unit>,
    staticMesh: Pointer<IPLStaticMesh>,
): IPLerror =
    IPLerror.fromInt(
        `iplStaticMeshLoad$mh`.invokeExact(
            scene,
            serializedObject,
            progressCallback,
            progressCallbackUserData,
            staticMesh,
        )
                as Int
    )

public fun iplStaticMeshSave(staticMesh: IPLStaticMesh, serializedObject: IPLSerializedObject): Unit =
    `iplStaticMeshSave$mh`.invokeExact(staticMesh, serializedObject) as Unit

public fun iplStaticMeshAdd(staticMesh: IPLStaticMesh, scene: IPLScene): Unit =
    `iplStaticMeshAdd$mh`.invokeExact(staticMesh, scene) as Unit

public fun iplStaticMeshRemove(staticMesh: IPLStaticMesh, scene: IPLScene): Unit =
    `iplStaticMeshRemove$mh`.invokeExact(staticMesh, scene) as Unit

public fun iplInstancedMeshCreate(
    scene: IPLScene,
    settings: Pointer<IPLInstancedMeshSettings>,
    instancedMesh: Pointer<IPLInstancedMesh>,
): IPLerror =
    IPLerror.fromInt(`iplInstancedMeshCreate$mh`.invokeExact(scene, settings, instancedMesh) as Int)

public fun iplInstancedMeshRetain(instancedMesh: IPLInstancedMesh): IPLInstancedMesh =
    `iplInstancedMeshRetain$mh`.invokeExact(instancedMesh) as MemorySegment

public fun iplInstancedMeshRelease(instancedMesh: Pointer<IPLInstancedMesh>): Unit =
    `iplInstancedMeshRelease$mh`.invokeExact(instancedMesh) as Unit

public fun iplInstancedMeshAdd(instancedMesh: IPLInstancedMesh, scene: IPLScene): Unit =
    `iplInstancedMeshAdd$mh`.invokeExact(instancedMesh, scene) as Unit

public fun iplInstancedMeshRemove(instancedMesh: IPLInstancedMesh, scene: IPLScene): Unit =
    `iplInstancedMeshRemove$mh`.invokeExact(instancedMesh, scene) as Unit

public fun iplInstancedMeshUpdateTransform(
    instancedMesh: IPLInstancedMesh,
    scene: IPLScene,
    transform: IPLMatrix4x4,
): Unit = `iplInstancedMeshUpdateTransform$mh`.invokeExact(instancedMesh, scene, transform.`$mem`) as
        Unit

public fun iplAudioBufferAllocate(
    context: IPLContext,
    numChannels: IPLint32,
    numSamples: IPLint32,
    audioBuffer: Pointer<IPLAudioBuffer>,
): IPLerror =
    IPLerror.fromInt(
        `iplAudioBufferAllocate$mh`.invokeExact(context, numChannels, numSamples, audioBuffer)
                as Int
    )

public fun iplAudioBufferFree(context: IPLContext, audioBuffer: Pointer<IPLAudioBuffer>): Unit =
    `iplAudioBufferFree$mh`.invokeExact(context, audioBuffer) as Unit

public fun iplAudioBufferInterleave(
    context: IPLContext,
    src: Pointer<IPLAudioBuffer>,
    dst: Pointer<IPLfloat32>,
): Unit = `iplAudioBufferInterleave$mh`.invokeExact(context, src, dst) as Unit

public fun iplAudioBufferDeinterleave(
    context: IPLContext,
    src: Pointer<IPLfloat32>,
    dst: Pointer<IPLAudioBuffer>,
): Unit = `iplAudioBufferDeinterleave$mh`.invokeExact(context, src, dst) as Unit

public fun iplAudioBufferMix(
    context: IPLContext,
    `in`: Pointer<IPLAudioBuffer>,
    mix: Pointer<IPLAudioBuffer>,
): Unit = `iplAudioBufferMix$mh`.invokeExact(context, `in`, mix) as Unit

public fun iplAudioBufferDownmix(
    context: IPLContext,
    `in`: Pointer<IPLAudioBuffer>,
    `out`: Pointer<IPLAudioBuffer>,
): Unit = `iplAudioBufferDownmix$mh`.invokeExact(context, `in`, `out`) as Unit

public fun iplAudioBufferConvertAmbisonics(
    context: IPLContext,
    inType: IPLAmbisonicsType,
    outType: IPLAmbisonicsType,
    `in`: Pointer<IPLAudioBuffer>,
    `out`: Pointer<IPLAudioBuffer>,
): Unit =
    `iplAudioBufferConvertAmbisonics$mh`.invokeExact(context, inType.value, outType.value, `in`, `out`)
            as Unit

public fun iplHRTFCreate(
    context: IPLContext,
    audioSettings: Pointer<IPLAudioSettings>,
    hrtfSettings: Pointer<IPLHRTFSettings>,
    hrtf: Pointer<IPLHRTF>,
): IPLerror =
    IPLerror.fromInt(
        `iplHRTFCreate$mh`.invokeExact(context, audioSettings, hrtfSettings, hrtf) as
                Int
    )

public fun iplHRTFRetain(hrtf: IPLHRTF): IPLHRTF = `iplHRTFRetain$mh`.invokeExact(hrtf) as
        MemorySegment

public fun iplHRTFRelease(hrtf: Pointer<IPLHRTF>): Unit = `iplHRTFRelease$mh`.invokeExact(hrtf) as
        Unit

public fun iplPanningEffectCreate(
    context: IPLContext,
    audioSettings: Pointer<IPLAudioSettings>,
    effectSettings: Pointer<IPLPanningEffectSettings>,
    effect: Pointer<IPLPanningEffect>,
): IPLerror =
    IPLerror.fromInt(
        `iplPanningEffectCreate$mh`.invokeExact(context, audioSettings, effectSettings, effect)
                as Int
    )

public fun iplPanningEffectRetain(effect: IPLPanningEffect): IPLPanningEffect =
    `iplPanningEffectRetain$mh`.invokeExact(effect) as MemorySegment

public fun iplPanningEffectRelease(effect: Pointer<IPLPanningEffect>): Unit =
    `iplPanningEffectRelease$mh`.invokeExact(effect) as Unit

public fun iplPanningEffectReset(effect: IPLPanningEffect): Unit =
    `iplPanningEffectReset$mh`.invokeExact(effect) as Unit

public fun iplPanningEffectApply(
    effect: IPLPanningEffect,
    params: Pointer<IPLPanningEffectParams>,
    `in`: Pointer<IPLAudioBuffer>,
    `out`: Pointer<IPLAudioBuffer>,
): IPLAudioEffectState =
    IPLAudioEffectState.fromInt(
        `iplPanningEffectApply$mh`.invokeExact(effect, params, `in`, `out`) as
                Int
    )

public fun iplBinauralEffectCreate(
    context: IPLContext,
    audioSettings: Pointer<IPLAudioSettings>,
    effectSettings: Pointer<IPLBinauralEffectSettings>,
    effect: Pointer<IPLBinauralEffect>,
): IPLerror =
    IPLerror.fromInt(
        `iplBinauralEffectCreate$mh`.invokeExact(context, audioSettings, effectSettings, effect)
                as Int
    )

public fun iplBinauralEffectRetain(effect: IPLBinauralEffect): IPLBinauralEffect =
    `iplBinauralEffectRetain$mh`.invokeExact(effect) as MemorySegment

public fun iplBinauralEffectRelease(effect: Pointer<IPLBinauralEffect>): Unit =
    `iplBinauralEffectRelease$mh`.invokeExact(effect) as Unit

public fun iplBinauralEffectReset(effect: IPLBinauralEffect): Unit =
    `iplBinauralEffectReset$mh`.invokeExact(effect) as Unit

public fun iplBinauralEffectApply(
    effect: IPLBinauralEffect,
    params: Pointer<IPLBinauralEffectParams>,
    `in`: Pointer<IPLAudioBuffer>,
    `out`: Pointer<IPLAudioBuffer>,
): IPLAudioEffectState =
    IPLAudioEffectState.fromInt(
        `iplBinauralEffectApply$mh`.invokeExact(effect, params, `in`, `out`)
                as Int
    )

public fun iplVirtualSurroundEffectCreate(
    context: IPLContext,
    audioSettings: Pointer<IPLAudioSettings>,
    effectSettings: Pointer<IPLVirtualSurroundEffectSettings>,
    effect: Pointer<IPLVirtualSurroundEffect>,
): IPLerror =
    IPLerror.fromInt(
        `iplVirtualSurroundEffectCreate$mh`.invokeExact(context, audioSettings, effectSettings, effect)
                as Int
    )

public fun iplVirtualSurroundEffectRetain(effect: IPLVirtualSurroundEffect):
        IPLVirtualSurroundEffect = `iplVirtualSurroundEffectRetain$mh`.invokeExact(effect) as
        MemorySegment

public fun iplVirtualSurroundEffectRelease(effect: Pointer<IPLVirtualSurroundEffect>): Unit =
    `iplVirtualSurroundEffectRelease$mh`.invokeExact(effect) as Unit

public fun iplVirtualSurroundEffectReset(effect: IPLVirtualSurroundEffect): Unit =
    `iplVirtualSurroundEffectReset$mh`.invokeExact(effect) as Unit

public fun iplVirtualSurroundEffectApply(
    effect: IPLVirtualSurroundEffect,
    params: Pointer<IPLVirtualSurroundEffectParams>,
    `in`: Pointer<IPLAudioBuffer>,
    `out`: Pointer<IPLAudioBuffer>,
): IPLAudioEffectState =
    IPLAudioEffectState.fromInt(
        `iplVirtualSurroundEffectApply$mh`.invokeExact(effect, params, `in`, `out`)
                as Int
    )

public fun iplAmbisonicsEncodeEffectCreate(
    context: IPLContext,
    audioSettings: Pointer<IPLAudioSettings>,
    effectSettings: Pointer<IPLAmbisonicsEncodeEffectSettings>,
    effect: Pointer<IPLAmbisonicsEncodeEffect>,
): IPLerror =
    IPLerror.fromInt(
        `iplAmbisonicsEncodeEffectCreate$mh`.invokeExact(context, audioSettings, effectSettings, effect)
                as Int
    )

public fun iplAmbisonicsEncodeEffectRetain(effect: IPLAmbisonicsEncodeEffect):
        IPLAmbisonicsEncodeEffect = `iplAmbisonicsEncodeEffectRetain$mh`.invokeExact(effect) as
        MemorySegment

public fun iplAmbisonicsEncodeEffectRelease(effect: Pointer<IPLAmbisonicsEncodeEffect>): Unit =
    `iplAmbisonicsEncodeEffectRelease$mh`.invokeExact(effect) as Unit

public fun iplAmbisonicsEncodeEffectReset(effect: IPLAmbisonicsEncodeEffect): Unit =
    `iplAmbisonicsEncodeEffectReset$mh`.invokeExact(effect) as Unit

public fun iplAmbisonicsEncodeEffectApply(
    effect: IPLAmbisonicsEncodeEffect,
    params: Pointer<IPLAmbisonicsEncodeEffectParams>,
    `in`: Pointer<IPLAudioBuffer>,
    `out`: Pointer<IPLAudioBuffer>,
): IPLAudioEffectState =
    IPLAudioEffectState.fromInt(
        `iplAmbisonicsEncodeEffectApply$mh`.invokeExact(effect, params, `in`, `out`)
                as Int
    )

public fun iplAmbisonicsPanningEffectCreate(
    context: IPLContext,
    audioSettings: Pointer<IPLAudioSettings>,
    effectSettings: Pointer<IPLAmbisonicsPanningEffectSettings>,
    effect: Pointer<IPLAmbisonicsPanningEffect>,
): IPLerror =
    IPLerror.fromInt(
        `iplAmbisonicsPanningEffectCreate$mh`.invokeExact(context, audioSettings, effectSettings, effect)
                as Int
    )

public fun iplAmbisonicsPanningEffectRetain(effect: IPLAmbisonicsPanningEffect):
        IPLAmbisonicsPanningEffect = `iplAmbisonicsPanningEffectRetain$mh`.invokeExact(effect) as
        MemorySegment

public fun iplAmbisonicsPanningEffectRelease(effect: Pointer<IPLAmbisonicsPanningEffect>): Unit =
    `iplAmbisonicsPanningEffectRelease$mh`.invokeExact(effect) as Unit

public fun iplAmbisonicsPanningEffectReset(effect: IPLAmbisonicsPanningEffect): Unit =
    `iplAmbisonicsPanningEffectReset$mh`.invokeExact(effect) as Unit

public fun iplAmbisonicsPanningEffectApply(
    effect: IPLAmbisonicsPanningEffect,
    params: Pointer<IPLAmbisonicsPanningEffectParams>,
    `in`: Pointer<IPLAudioBuffer>,
    `out`: Pointer<IPLAudioBuffer>,
): IPLAudioEffectState =
    IPLAudioEffectState.fromInt(
        `iplAmbisonicsPanningEffectApply$mh`.invokeExact(effect, params, `in`, `out`)
                as Int
    )

public fun iplAmbisonicsBinauralEffectCreate(
    context: IPLContext,
    audioSettings: Pointer<IPLAudioSettings>,
    effectSettings: Pointer<IPLAmbisonicsBinauralEffectSettings>,
    effect: Pointer<IPLAmbisonicsBinauralEffect>,
): IPLerror =
    IPLerror.fromInt(
        `iplAmbisonicsBinauralEffectCreate$mh`.invokeExact(context, audioSettings, effectSettings, effect)
                as Int
    )

public fun iplAmbisonicsBinauralEffectRetain(effect: IPLAmbisonicsBinauralEffect):
        IPLAmbisonicsBinauralEffect = `iplAmbisonicsBinauralEffectRetain$mh`.invokeExact(effect) as
        MemorySegment

public fun iplAmbisonicsBinauralEffectRelease(effect: Pointer<IPLAmbisonicsBinauralEffect>): Unit =
    `iplAmbisonicsBinauralEffectRelease$mh`.invokeExact(effect) as Unit

public fun iplAmbisonicsBinauralEffectReset(effect: IPLAmbisonicsBinauralEffect): Unit =
    `iplAmbisonicsBinauralEffectReset$mh`.invokeExact(effect) as Unit

public fun iplAmbisonicsBinauralEffectApply(
    effect: IPLAmbisonicsBinauralEffect,
    params: Pointer<IPLAmbisonicsBinauralEffectParams>,
    `in`: Pointer<IPLAudioBuffer>,
    `out`: Pointer<IPLAudioBuffer>,
): IPLAudioEffectState =
    IPLAudioEffectState.fromInt(
        `iplAmbisonicsBinauralEffectApply$mh`.invokeExact(effect, params, `in`, `out`)
                as Int
    )

public fun iplAmbisonicsRotationEffectCreate(
    context: IPLContext,
    audioSettings: Pointer<IPLAudioSettings>,
    effectSettings: Pointer<IPLAmbisonicsRotationEffectSettings>,
    effect: Pointer<IPLAmbisonicsRotationEffect>,
): IPLerror =
    IPLerror.fromInt(
        `iplAmbisonicsRotationEffectCreate$mh`.invokeExact(context, audioSettings, effectSettings, effect)
                as Int
    )

public fun iplAmbisonicsRotationEffectRetain(effect: IPLAmbisonicsRotationEffect):
        IPLAmbisonicsRotationEffect = `iplAmbisonicsRotationEffectRetain$mh`.invokeExact(effect) as
        MemorySegment

public fun iplAmbisonicsRotationEffectRelease(effect: Pointer<IPLAmbisonicsRotationEffect>): Unit =
    `iplAmbisonicsRotationEffectRelease$mh`.invokeExact(effect) as Unit

public fun iplAmbisonicsRotationEffectReset(effect: IPLAmbisonicsRotationEffect): Unit =
    `iplAmbisonicsRotationEffectReset$mh`.invokeExact(effect) as Unit

public fun iplAmbisonicsRotationEffectApply(
    effect: IPLAmbisonicsRotationEffect,
    params: Pointer<IPLAmbisonicsRotationEffectParams>,
    `in`: Pointer<IPLAudioBuffer>,
    `out`: Pointer<IPLAudioBuffer>,
): IPLAudioEffectState =
    IPLAudioEffectState.fromInt(
        `iplAmbisonicsRotationEffectApply$mh`.invokeExact(effect, params, `in`, `out`)
                as Int
    )

public fun iplAmbisonicsDecodeEffectCreate(
    context: IPLContext,
    audioSettings: Pointer<IPLAudioSettings>,
    effectSettings: Pointer<IPLAmbisonicsDecodeEffectSettings>,
    effect: Pointer<IPLAmbisonicsDecodeEffect>,
): IPLerror =
    IPLerror.fromInt(
        `iplAmbisonicsDecodeEffectCreate$mh`.invokeExact(context, audioSettings, effectSettings, effect)
                as Int
    )

public fun iplAmbisonicsDecodeEffectRetain(effect: IPLAmbisonicsDecodeEffect):
        IPLAmbisonicsDecodeEffect = `iplAmbisonicsDecodeEffectRetain$mh`.invokeExact(effect) as
        MemorySegment

public fun iplAmbisonicsDecodeEffectRelease(effect: Pointer<IPLAmbisonicsDecodeEffect>): Unit =
    `iplAmbisonicsDecodeEffectRelease$mh`.invokeExact(effect) as Unit

public fun iplAmbisonicsDecodeEffectReset(effect: IPLAmbisonicsDecodeEffect): Unit =
    `iplAmbisonicsDecodeEffectReset$mh`.invokeExact(effect) as Unit

public fun iplAmbisonicsDecodeEffectApply(
    effect: IPLAmbisonicsDecodeEffect,
    params: Pointer<IPLAmbisonicsDecodeEffectParams>,
    `in`: Pointer<IPLAudioBuffer>,
    `out`: Pointer<IPLAudioBuffer>,
): IPLAudioEffectState =
    IPLAudioEffectState.fromInt(
        `iplAmbisonicsDecodeEffectApply$mh`.invokeExact(effect, params, `in`, `out`)
                as Int
    )

public fun iplDirectEffectCreate(
    context: IPLContext,
    audioSettings: Pointer<IPLAudioSettings>,
    effectSettings: Pointer<IPLDirectEffectSettings>,
    effect: Pointer<IPLDirectEffect>,
): IPLerror =
    IPLerror.fromInt(
        `iplDirectEffectCreate$mh`.invokeExact(context, audioSettings, effectSettings, effect)
                as Int
    )

public fun iplDirectEffectRetain(effect: IPLDirectEffect): IPLDirectEffect =
    `iplDirectEffectRetain$mh`.invokeExact(effect) as MemorySegment

public fun iplDirectEffectRelease(effect: Pointer<IPLDirectEffect>): Unit =
    `iplDirectEffectRelease$mh`.invokeExact(effect) as Unit

public fun iplDirectEffectReset(effect: IPLDirectEffect): Unit =
    `iplDirectEffectReset$mh`.invokeExact(effect) as Unit

public fun iplDirectEffectApply(
    effect: IPLDirectEffect,
    params: Pointer<IPLDirectEffectParams>,
    `in`: Pointer<IPLAudioBuffer>,
    `out`: Pointer<IPLAudioBuffer>,
): IPLAudioEffectState =
    IPLAudioEffectState.fromInt(
        `iplDirectEffectApply$mh`.invokeExact(effect, params, `in`, `out`) as
                Int
    )

public fun iplReflectionEffectCreate(
    context: IPLContext,
    audioSettings: Pointer<IPLAudioSettings>,
    effectSettings: Pointer<IPLReflectionEffectSettings>,
    effect: Pointer<IPLReflectionEffect>,
): IPLerror =
    IPLerror.fromInt(
        `iplReflectionEffectCreate$mh`.invokeExact(context, audioSettings, effectSettings, effect)
                as Int
    )

public fun iplReflectionEffectRetain(effect: IPLReflectionEffect): IPLReflectionEffect =
    `iplReflectionEffectRetain$mh`.invokeExact(effect) as MemorySegment

public fun iplReflectionEffectRelease(effect: Pointer<IPLReflectionEffect>): Unit =
    `iplReflectionEffectRelease$mh`.invokeExact(effect) as Unit

public fun iplReflectionEffectReset(effect: IPLReflectionEffect): Unit =
    `iplReflectionEffectReset$mh`.invokeExact(effect) as Unit

public fun iplReflectionEffectApply(
    effect: IPLReflectionEffect,
    params: Pointer<IPLReflectionEffectParams>,
    `in`: Pointer<IPLAudioBuffer>,
    `out`: Pointer<IPLAudioBuffer>,
    mixer: IPLReflectionMixer,
): IPLAudioEffectState =
    IPLAudioEffectState.fromInt(
        `iplReflectionEffectApply$mh`.invokeExact(effect, params, `in`, `out`, mixer)
                as Int
    )

public fun iplReflectionMixerCreate(
    context: IPLContext,
    audioSettings: Pointer<IPLAudioSettings>,
    effectSettings: Pointer<IPLReflectionEffectSettings>,
    mixer: Pointer<IPLReflectionMixer>,
): IPLerror =
    IPLerror.fromInt(
        `iplReflectionMixerCreate$mh`.invokeExact(context, audioSettings, effectSettings, mixer)
                as Int
    )

public fun iplReflectionMixerRetain(mixer: IPLReflectionMixer): IPLReflectionMixer =
    `iplReflectionMixerRetain$mh`.invokeExact(mixer) as MemorySegment

public fun iplReflectionMixerRelease(mixer: Pointer<IPLReflectionMixer>): Unit =
    `iplReflectionMixerRelease$mh`.invokeExact(mixer) as Unit

public fun iplReflectionMixerReset(mixer: IPLReflectionMixer): Unit =
    `iplReflectionMixerReset$mh`.invokeExact(mixer) as Unit

public fun iplReflectionMixerApply(
    mixer: IPLReflectionMixer,
    params: Pointer<IPLReflectionEffectParams>,
    `out`: Pointer<IPLAudioBuffer>,
): IPLAudioEffectState =
    IPLAudioEffectState.fromInt(
        `iplReflectionMixerApply$mh`.invokeExact(mixer, params, `out`) as
                Int
    )

public fun iplPathEffectCreate(
    context: IPLContext,
    audioSettings: Pointer<IPLAudioSettings>,
    effectSettings: Pointer<IPLPathEffectSettings>,
    effect: Pointer<IPLPathEffect>,
): IPLerror =
    IPLerror.fromInt(
        `iplPathEffectCreate$mh`.invokeExact(context, audioSettings, effectSettings, effect)
                as Int
    )

public fun iplPathEffectRetain(effect: IPLPathEffect): IPLPathEffect =
    `iplPathEffectRetain$mh`.invokeExact(effect) as MemorySegment

public fun iplPathEffectRelease(effect: Pointer<IPLPathEffect>): Unit =
    `iplPathEffectRelease$mh`.invokeExact(effect) as Unit

public fun iplPathEffectReset(effect: IPLPathEffect): Unit =
    `iplPathEffectReset$mh`.invokeExact(effect) as Unit

public fun iplPathEffectApply(
    effect: IPLPathEffect,
    params: Pointer<IPLPathEffectParams>,
    `in`: Pointer<IPLAudioBuffer>,
    `out`: Pointer<IPLAudioBuffer>,
): IPLAudioEffectState =
    IPLAudioEffectState.fromInt(
        `iplPathEffectApply$mh`.invokeExact(effect, params, `in`, `out`) as
                Int
    )

public fun iplProbeArrayCreate(context: IPLContext, probeArray: Pointer<IPLProbeArray>): IPLerror =
    IPLerror.fromInt(`iplProbeArrayCreate$mh`.invokeExact(context, probeArray) as Int)

public fun iplProbeArrayRetain(probeArray: IPLProbeArray): IPLProbeArray =
    `iplProbeArrayRetain$mh`.invokeExact(probeArray) as MemorySegment

public fun iplProbeArrayRelease(probeArray: Pointer<IPLProbeArray>): Unit =
    `iplProbeArrayRelease$mh`.invokeExact(probeArray) as Unit

public fun iplProbeArrayGenerateProbes(
    probeArray: IPLProbeArray,
    scene: IPLScene,
    params: Pointer<IPLProbeGenerationParams>,
): Unit = `iplProbeArrayGenerateProbes$mh`.invokeExact(probeArray, scene, params) as Unit

public fun iplProbeArrayGetNumProbes(probeArray: IPLProbeArray): IPLint32 =
    `iplProbeArrayGetNumProbes$mh`.invokeExact(probeArray) as Int

context(SegmentAllocator)
public fun iplProbeArrayGetProbe(probeArray: IPLProbeArray, index: IPLint32): IPLSphere =
    IPLSphere(
        `iplProbeArrayGetProbe$mh`.invokeExact(this@SegmentAllocator, probeArray, index) as
                MemorySegment
    )

public fun iplProbeBatchCreate(context: IPLContext, probeBatch: Pointer<IPLProbeBatch>): IPLerror =
    IPLerror.fromInt(`iplProbeBatchCreate$mh`.invokeExact(context, probeBatch) as Int)

public fun iplProbeBatchRetain(probeBatch: IPLProbeBatch): IPLProbeBatch =
    `iplProbeBatchRetain$mh`.invokeExact(probeBatch) as MemorySegment

public fun iplProbeBatchRelease(probeBatch: Pointer<IPLProbeBatch>): Unit =
    `iplProbeBatchRelease$mh`.invokeExact(probeBatch) as Unit

public fun iplProbeBatchLoad(
    context: IPLContext,
    serializedObject: IPLSerializedObject,
    probeBatch: Pointer<IPLProbeBatch>,
): IPLerror =
    IPLerror.fromInt(
        `iplProbeBatchLoad$mh`.invokeExact(context, serializedObject, probeBatch) as
                Int
    )

public fun iplProbeBatchSave(probeBatch: IPLProbeBatch, serializedObject: IPLSerializedObject): Unit =
    `iplProbeBatchSave$mh`.invokeExact(probeBatch, serializedObject) as Unit

public fun iplProbeBatchGetNumProbes(probeBatch: IPLProbeBatch): IPLint32 =
    `iplProbeBatchGetNumProbes$mh`.invokeExact(probeBatch) as Int

public fun iplProbeBatchAddProbe(probeBatch: IPLProbeBatch, probe: IPLSphere): Unit =
    `iplProbeBatchAddProbe$mh`.invokeExact(probeBatch, probe.`$mem`) as Unit

public fun iplProbeBatchAddProbeArray(probeBatch: IPLProbeBatch, probeArray: IPLProbeArray): Unit =
    `iplProbeBatchAddProbeArray$mh`.invokeExact(probeBatch, probeArray) as Unit

public fun iplProbeBatchRemoveProbe(probeBatch: IPLProbeBatch, index: IPLint32): Unit =
    `iplProbeBatchRemoveProbe$mh`.invokeExact(probeBatch, index) as Unit

public fun iplProbeBatchCommit(probeBatch: IPLProbeBatch): Unit =
    `iplProbeBatchCommit$mh`.invokeExact(probeBatch) as Unit

public fun iplProbeBatchRemoveData(
    probeBatch: IPLProbeBatch,
    identifier: Pointer<IPLBakedDataIdentifier>
): Unit =
    `iplProbeBatchRemoveData$mh`.invokeExact(probeBatch, identifier) as Unit

public fun iplProbeBatchGetDataSize(
    probeBatch: IPLProbeBatch,
    identifier: Pointer<IPLBakedDataIdentifier>
): IPLsize =
    (`iplProbeBatchGetDataSize$mh`.invokeExact(probeBatch, identifier) as Long).toULong()

public fun iplReflectionsBakerBake(
    context: IPLContext,
    params: Pointer<IPLReflectionsBakeParams>,
    progressCallback: IPLProgressCallback,
    userData: Pointer<Unit>,
): Unit = `iplReflectionsBakerBake$mh`.invokeExact(context, params, progressCallback, userData) as
        Unit

public fun iplReflectionsBakerCancelBake(context: IPLContext): Unit =
    `iplReflectionsBakerCancelBake$mh`.invokeExact(context) as Unit

public fun iplPathBakerBake(
    context: IPLContext,
    params: Pointer<IPLPathBakeParams>,
    progressCallback: IPLProgressCallback,
    userData: Pointer<Unit>,
): Unit = `iplPathBakerBake$mh`.invokeExact(context, params, progressCallback, userData) as Unit

public fun iplPathBakerCancelBake(context: IPLContext): Unit =
    `iplPathBakerCancelBake$mh`.invokeExact(context) as Unit

public fun iplSimulatorCreate(
    context: IPLContext,
    settings: Pointer<IPLSimulationSettings>,
    simulator: Pointer<IPLSimulator>,
): IPLerror = IPLerror.fromInt(
    `iplSimulatorCreate$mh`.invokeExact(context, settings, simulator) as
            Int
)

public fun iplSimulatorRetain(simulator: IPLSimulator): IPLSimulator =
    `iplSimulatorRetain$mh`.invokeExact(simulator) as MemorySegment

public fun iplSimulatorRelease(simulator: Pointer<IPLSimulator>): Unit =
    `iplSimulatorRelease$mh`.invokeExact(simulator) as Unit

public fun iplSimulatorSetScene(simulator: IPLSimulator, scene: IPLScene): Unit =
    `iplSimulatorSetScene$mh`.invokeExact(simulator, scene) as Unit

public fun iplSimulatorAddProbeBatch(simulator: IPLSimulator, probeBatch: IPLProbeBatch): Unit =
    `iplSimulatorAddProbeBatch$mh`.invokeExact(simulator, probeBatch) as Unit

public fun iplSimulatorRemoveProbeBatch(simulator: IPLSimulator, probeBatch: IPLProbeBatch): Unit =
    `iplSimulatorRemoveProbeBatch$mh`.invokeExact(simulator, probeBatch) as Unit

public fun iplSimulatorSetSharedInputs(
    simulator: IPLSimulator,
    flags: IPLSimulationFlags,
    sharedInputs: Pointer<IPLSimulationSharedInputs>,
): Unit = `iplSimulatorSetSharedInputs$mh`.invokeExact(simulator, flags.value, sharedInputs) as Unit

public fun iplSimulatorCommit(simulator: IPLSimulator): Unit =
    `iplSimulatorCommit$mh`.invokeExact(simulator) as Unit

public fun iplSimulatorRunDirect(simulator: IPLSimulator): Unit =
    `iplSimulatorRunDirect$mh`.invokeExact(simulator) as Unit

public fun iplSimulatorRunReflections(simulator: IPLSimulator): Unit =
    `iplSimulatorRunReflections$mh`.invokeExact(simulator) as Unit

public fun iplSimulatorRunPathing(simulator: IPLSimulator): Unit =
    `iplSimulatorRunPathing$mh`.invokeExact(simulator) as Unit

public fun iplSourceCreate(
    simulator: IPLSimulator,
    settings: Pointer<IPLSourceSettings>,
    source: Pointer<IPLSource>,
): IPLerror = IPLerror.fromInt(`iplSourceCreate$mh`.invokeExact(simulator, settings, source) as Int)

public fun iplSourceRetain(source: IPLSource): IPLSource = `iplSourceRetain$mh`.invokeExact(source)
        as MemorySegment

public fun iplSourceRelease(source: Pointer<IPLSource>): Unit =
    `iplSourceRelease$mh`.invokeExact(source) as Unit

public fun iplSourceAdd(source: IPLSource, simulator: IPLSimulator): Unit =
    `iplSourceAdd$mh`.invokeExact(source, simulator) as Unit

public fun iplSourceRemove(source: IPLSource, simulator: IPLSimulator): Unit =
    `iplSourceRemove$mh`.invokeExact(source, simulator) as Unit

public fun iplSourceSetInputs(
    source: IPLSource,
    flags: IPLSimulationFlags,
    inputs: Pointer<IPLSimulationInputs>,
): Unit = `iplSourceSetInputs$mh`.invokeExact(source, flags.value, inputs) as Unit

public fun iplSourceGetOutputs(
    source: IPLSource,
    flags: IPLSimulationFlags,
    outputs: Pointer<IPLSimulationOutputs>,
): Unit = `iplSourceGetOutputs$mh`.invokeExact(source, flags.value, outputs) as Unit

public fun iplDistanceAttenuationCalculate(
    context: IPLContext,
    source: IPLVector3,
    listener: IPLVector3,
    model: Pointer<IPLDistanceAttenuationModel>,
): IPLfloat32 =
    `iplDistanceAttenuationCalculate$mh`.invokeExact(context, source.`$mem`, listener.`$mem`, model)
            as Float

public fun iplAirAbsorptionCalculate(
    context: IPLContext,
    source: IPLVector3,
    listener: IPLVector3,
    model: Pointer<IPLAirAbsorptionModel>,
    airAbsorption: Pointer<IPLfloat32>,
): Unit =
    `iplAirAbsorptionCalculate$mh`.invokeExact(context, source.`$mem`, listener.`$mem`, model, airAbsorption)
            as Unit

public fun iplDirectivityCalculate(
    context: IPLContext,
    source: IPLCoordinateSpace3,
    listener: IPLVector3,
    model: Pointer<IPLDirectivity>,
): IPLfloat32 =
    `iplDirectivityCalculate$mh`.invokeExact(context, source.`$mem`, listener.`$mem`, model) as Float
